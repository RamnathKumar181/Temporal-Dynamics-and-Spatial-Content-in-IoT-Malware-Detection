import numpy as np
import pandas as pd
benign =  np.load('benign_data_preprocessing_64.npy', encoding = 'latin1') # MODEL  1
malware = np.load('malware_data_preprocessing_64.npy', encoding = 'latin1')

from sklearn.model_selection import train_test_split
A_benign,B_benign = train_test_split(benign,test_size=0.2,random_state=5)
A_malware,B_malware = train_test_split(malware,test_size=0.2,random_state=5)

training_data  = []
cnt_ben=0
cnt_mal=0
for i in A_benign:
    cnt_ben+=1
    training_data.append(i)
for i in A_malware:
    cnt_mal+=1
    training_data.append(i)

print(cnt_ben)
print(cnt_mal)
print(len(training_data))
cnt_ben=0
cnt_mal=0

test_data  = []
for i in B_benign:
    cnt_ben+=1
    test_data.append(i)
for i in B_malware:
    cnt_mal+=1
    test_data.append(i)

print(cnt_ben)
print(cnt_mal)

print(len(test_data))

import numpy as np
from keras.layers import *
from keras.models import Model
from  keras.models import Input
from keras import optimizers
from keras.callbacks import ReduceLROnPlateau
from keras.callbacks import ModelCheckpoint
from keras.layers.normalization import BatchNormalization
from keras.layers import Dropout
import matplotlib.pyplot as plt
from keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import cohen_kappa_score
from keras import regularizers
import pandas as pd
import matplotlib.pyplot as plt
X_train = np.array([i[0] for i in training_data])
y_train = np.array([i[1] for i in training_data])
print(y_train)
X_test = np.array([i[0] for i in test_data])
y_test = np.array([i[1] for i in test_data])
print(y_test)
import numpy as np
from keras.layers import *
from keras.models import Model
from  keras.models import Input
from keras import optimizers
from keras.callbacks import ReduceLROnPlateau
from keras.callbacks import ModelCheckpoint
from keras.layers.normalization import BatchNormalization
from keras.layers import Dropout
import matplotlib.pyplot as plt
from keras.layers import GlobalAveragePooling2D
from keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import cohen_kappa_score
from keras.layers import Concatenate
from keras.layers import add
from keras import regularizers
from sklearn.metrics import confusion_matrix
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import OneHotEncoder
from keras.applications import xception
from keras.applications import densenet
import os

# Importing the Keras libraries and packages
from keras.models import Sequential
from keras.layers import Convolution2D
from keras.layers import MaxPooling2D
from keras.layers import Flatten
from keras.layers import Dense
from  os import listdir,makedirs
from os.path import join,exists,expanduser

y = Input(shape=(64,64,3))

x = Conv2D(32,3,activation='relu')(y)

z = Conv2D(32,3,activation='sigmoid')(y)

x = add([x,z])
x = MaxPooling2D(strides=(2,2))(x)
x = BatchNormalization()(x)

a = Conv2D(72,3,activation='relu')(x)

z = Conv2D(72,3,activation='sigmoid')(x)

con1 = add([a,z])

a = Conv2D(72,3,activation='relu')(x)

z = Conv2D(72,3,activation='sigmoid')(x)

con2 = add([a,z])

x = add([con1,con2])

x = MaxPooling2D(strides=(2,2))(x)
x = BatchNormalization()(x)

x=Flatten()(x)

x=Dense(output_dim = 256, activation = 'relu',kernel_regularizer = regularizers.l2(0.001))(x)
x = Dropout(0.12)(x)

output =Dense(output_dim = 1, activation = 'sigmoid',kernel_regularizer = regularizers.l2(0.001))(x)

model = Model(inputs = y, outputs = output)
model.load_weights('cnn.hdf5')
adam = optimizers.Adam(lr=1e-3,beta_1=0.9,beta_2=0.999)
# sgd = optimizers.SGD(lr=1e-3, decay=1e-6, momentum=0.9, nesterov=True)
model.compile(optimizer = adam, loss = 'binary_crossentropy', metrics = ['accuracy'])


print("Learning rate: ", 0.05)
print("Accuracy score (training): {0:.3f}".format(model.score(X_train, y_train)))
print("Accuracy score (validation): {0:.3f}".format(model.score(X_test, y_test)))
print()
predictions = model.predict(X_test)
print("Confusion Matrix:")
print(confusion_matrix(y_test, predictions))
print()
print("Classification Report")
print(classification_report(y_test, predictions))
y_scores_gb = model.decision_function(X_test)
fpr_gb, tpr_gb, _ = roc_curve(y_test, y_scores_gb)
roc_auc_gb = auc(fpr_gb, tpr_gb)
print("Area under ROC curve = {:0.2f}".format(roc_auc_gb))
