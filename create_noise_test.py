import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
from random import shuffle
import random
from scipy import ndimage

# training_path = 'Malware Images'
training_path = 'Benign images'


def adjust_gamma(image, gamma=1.0):
	# build a lookup table mapping the pixel values [0, 255] to
	# their adjusted gamma values
	invGamma = 1.0 / gamma
	table = np.array([((i / 255.0) ** invGamma) * 255
		for i in np.arange(0, 256)]).astype("uint8")

	# apply gamma correction using the lookup table
	return cv2.LUT(image, table)

def load_images_and_label(path,training_data):
	for filename in os.listdir(path):
		img = cv2.resize(cv2.imread(os.path.join(path,filename)),(64,64))
		if img is not None:
		    print(path+'/'+filename)
		    # edges = cv2.Canny(img,2,50)
		    # mask = np.zeros(img.shape)
		    # contours, hierarchy = cv2.findContours(edges,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
		    # cv2.drawContours(mask, contours, -1,(255,255,255),-1)
		    # kernel = np.ones((5,5),np.uint8)
		    # dilation = cv2.dilate(mask,kernel,iterations = 2)
		    # kernel2 = np.ones((30,40),np.uint8)
		    # closing = cv2.morphologyEx(dilation, cv2.MORPH_CLOSE, kernel2)
		    # img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)
		    # img_yuv[:,:,0] = cv2.equalizeHist(img_yuv[:,:,0])
		    # img_output = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)
		    # img_output = adjust_gamma(img_output,0.07)
		    # dst = cv2.resize(img_output,(320,320))
		    # blur = cv2.GaussianBlur(dst,(7,7),0)
		    # unsharp_image = cv2.addWeighted(dst, 1.25, blur, -0.5, 0, dst)
		    # blur = cv2.GaussianBlur(unsharp_image,(15,15),0)
		    # unsharp_image = cv2.addWeighted(unsharp_image, 1.25, blur, -0.5, 0, unsharp_image)
		    # blur = cv2.GaussianBlur(unsharp_image,(15,15),0)
		    # unsharp_image = cv2.addWeighted(unsharp_image, 1.5, blur, -0.5, 0, unsharp_image)
		    # dst = cv2.resize(unsharp_image,(128,128))
		    # # dst[np.where((closing==[0,0,0]).all(axis=2))] = [0,0,0]
		    dst =  np.array(img)
		    dst = dst.astype('float32')
		    dst /= 255
		    training_data.append([np.array(dst),0])
	return training_data


def create_train_data():
	training_data = []
	training_data = load_images_and_label(training_path,training_data)
	np.save('benign_data_preprocessing_64.npy',training_data)

create_train_data()
